package com.orchestranetworks.ps.codegen;

import java.io.*;
import java.util.*;

import org.apache.commons.lang3.*;

import com.onwbp.base.schema.definition.*;
import com.orchestranetworks.ps.export.*;
import com.orchestranetworks.ps.util.*;
import com.orchestranetworks.schema.*;
import com.orchestranetworks.schema.info.*;

/**
 * Java bean generation executed for each table in a data set.
 * All bean properties are implemented to delegate to either a valueContext or an adaptation.
 */
public class JavaBeanExporter extends FileExporter
{
	private static final String CLASS_COMMENT = "/**" + System.lineSeparator()
		+ " * Generated by EBX5 5.5.1 Fix G [0964:0010], at  2016/01/14 09:46:59 [EST]."
		+ System.lineSeparator()
		+ " * WARNING: Any manual changes to this class may be overwritten by generation process."
		+ System.lineSeparator() + " * DO NOT MODIFY THIS CLASS." + System.lineSeparator() + " */";
	private static final String INDENT = "\t";
	private static final String REC_VAR_NAME = "_record";
	private static final String CONTEXT_VAR_NAME = "_context";

	private final SchemaNode tableNode;
	public JavaBeanExporter(
		String parentDir,
		String exportDir,
		Locale locale,
		boolean appendTimestamp,
		SchemaNode tableNode)
		throws IOException
	{
		super(
			parentDir,
			exportDir,
			locale,
			NameUtils.makeClassName(tableNode.getLabel(locale)),
			".java",
			appendTimestamp);
		this.tableNode = tableNode;
	}

	@Override
	public String doExport() throws IOException
	{
		final BufferedWriter writer = new BufferedWriter(new FileWriter(this.exportFilePath));
		writeClass(writer);
		writer.flush();
		writer.close();
		return this.exportFilePath;
	}

	public static BufferedWriter writeIndent(BufferedWriter writer, int depth) throws IOException
	{
		for (int i = 0; i < depth; i++)
		{
			writer.write(INDENT);
		}
		return writer;
	}

	public static void writeBreak(BufferedWriter writer) throws IOException
	{
		writer.newLine();
		writer.newLine();
	}

	private void writeClass(BufferedWriter writer) throws IOException
	{
		writer.write(CLASS_COMMENT);
		writer.newLine();
		// TODO: how do we find the java package to generate into: for now, use default package
		List<Field> fields = new ArrayList<>();
		createFields(fields, tableNode.getTableOccurrenceRootNode().getNodeChildren(), null);
		writeImports(writer, fields);
		String tableName = NameUtils.makeClassName(tableNode.getLabel(locale));
		writer.append("public class ").append(tableName).append(" {");
		writer.newLine();
		// write the instance variables
		writeIndent(writer, 1).append("private Adaptation _record;");
		writer.newLine();
		writeIndent(writer, 1).append("private ValueContext _context;");
		writer.newLine();
		writeIndent(writer, 1).append("public static final UnaryFunction<Adaptation,")
			.append(tableName)
			.append("> NEW_FROM_RECORD = new UnaryFunction<Adaptation,")
			.append(tableName)
			.append(">() {");
		writer.newLine();
		writeIndent(writer, 2).append("@Override");
		writer.newLine();
		writeIndent(writer, 2).append("public ").append(tableName).append(
			" evaluate(Adaptation record) {");
		writer.newLine();
		writeIndent(writer, 3).append("return new ").append(tableName).append("(record);");
		writer.newLine();
		writeIndent(writer, 2).append("}");
		writer.newLine();
		writeIndent(writer, 1).append("};");
		writer.newLine();
		// write constructors
		writeIndent(writer, 1).append("public ").append(tableName).append("() {}");
		writeBreak(writer);
		writeIndent(writer, 1).write("/** Construct an instance with an adaptation */");
		writer.newLine();
		writeIndent(writer, 1).append("public ").append(tableName).append("(Adaptation record) {");
		writer.newLine();
		writeIndent(writer, 2).append("setRecord(record);");
		writer.newLine();
		writeIndent(writer, 1).append("}");
		writeBreak(writer);
		writeIndent(writer, 1).write("/** Construct an instance with a value context */");
		writer.newLine();
		writeIndent(writer, 1).append("public ").append(tableName).append(
			"(ValueContext context) {");
		writer.newLine();
		writeIndent(writer, 2).append("setContext(context);");
		writer.newLine();
		writeIndent(writer, 1).append("}");
		writeBreak(writer);
		// write the getters/setters
		writeIndent(writer, 1).append("public void setRecord(Adaptation record) {");
		writer.newLine();
		writeIndent(writer, 2).append("this._record = record;");
		writer.newLine();
		writeIndent(writer, 1).append("}");
		writeBreak(writer);
		writeIndent(writer, 1).append("public void setContext(ValueContext context) {");
		writer.newLine();
		writeIndent(writer, 2).append("this._context = context;");
		writer.newLine();
		writeIndent(writer, 1).append("}");
		writeBreak(writer);
		writeIndent(writer, 1).append("public ValueContextForUpdate getValueContextForUpdate() {");
		writer.newLine();
		writeIndent(writer, 2).append("if (_context == null && _record != null)");
		writer.newLine();
		writeIndent(writer, 3).append("_context = _record.createValueContext();");
		writer.newLine();
		writeIndent(writer, 2).append("if (_context instanceof ValueContextForUpdate)");
		writer.newLine();
		writeIndent(writer, 3).append("return (ValueContextForUpdate) _context;");
		writer.newLine();
		writeIndent(writer, 2).append("return null;");
		writer.newLine();
		writeIndent(writer, 1).append("}");
		writeBreak(writer);
		writeIndent(writer, 1).append("public PrimaryKey getPrimaryKey() {");
		writer.newLine();
		writeIndent(writer, 2).append("if (_record == null && _context != null)");
		writer.newLine();
		writeIndent(writer, 3).append("_record = _context.getAdaptationInstance();");
		writer.newLine();
		writeIndent(writer, 2).append("if (_record != null)");
		writer.newLine();
		writeIndent(writer, 3).append("return _record.getOccurrencePrimaryKey();");
		writer.newLine();
		writeIndent(writer, 2).append("return null;");
		writer.newLine();
		writeIndent(writer, 1).append("}");
		writeBreak(writer);

		boolean hasEnum = false;
		for (Field field : fields)
		{
			writeAccessMethods(writer, field);
			if (field.enums != null)
				hasEnum = true;
		}
		writeBreak(writer);
		// if there are any enumerations, write inner classes for those constants
		if (hasEnum)
		{
			for (Field field : fields)
			{
				if (field.enums != null)
					writeEnumClass(writer, field);
			}
		}
		writer.write("}");
		writer.newLine();
	}

	/** Generate the required import statements and return whether there are any complex fields */
	private void writeImports(BufferedWriter writer, List<Field> fields) throws IOException
	{
		writer.write("import com.onwbp.adaptation.*;");
		writer.newLine();
		writer.write("import com.orchestranetworks.instance.*;");
		writer.newLine();
		writer.write("import com.orchestranetworks.ps.util.functional.*;");
		writer.newLine();
		writer.write("import com.orchestranetworks.schema.*;");
		writer.newLine();
		writer.write("import com.orchestranetworks.service.*;");
		writer.newLine();
		boolean needJavaUtil = false;
		boolean needJavaMath = false;
		boolean needJavaNet = false;
		boolean needPsUtil = false;
		for (Field field : fields)
		{
			if (field.relationship)
				needPsUtil = true;
			if (field.collection || "Date".equals(field.baseName)
				|| "Timestamp".equals(field.baseName) || "Time".equals(field.baseName))
				needJavaUtil = true;
			if ("BigDecimal".equals(field.baseName))
				needJavaMath = true;
			if (field.baseName.equals("URI"))
				needJavaNet = true;
		}
		if (needPsUtil)
		{
			writer.write("import com.orchestranetworks.ps.util.*;");
			writer.newLine();
		}
		if (needJavaUtil)
		{
			writer.write("import java.util.*;");
			writer.newLine();
		}
		if (needJavaMath)
		{
			writer.write("import java.math.*;");
			writer.newLine();
		}
		if (needJavaNet)
		{
			writer.write("import java.net.*;");
			writer.newLine();
		}
	}

	private void writeAccessMethods(BufferedWriter writer, Field field) throws IOException
	{
		String capName = StringUtils.capitalize(field.name);
		writeIndent(writer, 1).append("public ")
			.append(field.typeName)
			.append(" get")
			.append(capName)
			.append("() {");
		writer.newLine();
		String path = "Path.parse(\"." + field.node.getPathInAdaptation().format() + "\")";
		if (field.relationship)
		{
			if (field.fk && !field.collection)
			{
				writeIndent(writer, 2).append("Adaptation _result = null;");
				writeIndent(writer, 2).append("if (_record != null) {");
				writer.newLine();
				writeIndent(writer, 3).append("_result = AdaptationUtil.followFK(_record,");
				writer.newLine();
				writeIndent(writer, 4).append(path).append(");");
				writer.newLine();
				writeIndent(writer, 2).append("} else if (_context != null) {");
				writer.newLine();
				writeIndent(writer, 3).append("_result = AdaptationUtil.followFK(_context,");
				writer.newLine();
				writeIndent(writer, 4).append(path).append(");");
				writer.newLine();
				writeIndent(writer, 2).write("}");
				writer.newLine();
				writeIndent(writer, 2).append("return _result == null ? null : new ")
					.append(field.baseName)
					.append("(_result);");
			}
			else
			{
				writeIndent(writer, 2)
					.append("List<Adaptation> list = AdaptationUtil.evaluateSingle(");
				writer.newLine();
				writeIndent(writer, 3).append("_record, _context,");
				writer.newLine();
				writeIndent(writer, 3).append(path).append(");");
				writer.newLine();
				if (field.collection)
				{
					writeIndent(writer, 2).append("return Algorithms.apply(list, ")
						.append(field.baseName)
						.append(".NEW_FROM_RECORD);");
				}
				else
				{
					writeIndent(writer, 2).append("return list.isEmpty() ? null : new ")
						.append(field.typeName)
						.append("(list.get(0));");
				}
			}
		}
		else
		{
			writeIndent(writer, 2).append("if (_record != null) {");
			writer.newLine();
			writeFieldGetter(writer, field, path, true);
			writer.newLine();
			writeIndent(writer, 2).append("} else if (_context != null) {");
			writer.newLine();
			writeFieldGetter(writer, field, path, false);
			writeIndent(writer, 2).append("}");
			writer.newLine();
			writeIndent(writer, 2).append("return null;");
		}
		writer.newLine();
		writeIndent(writer, 1).write("}");
		writeBreak(writer);
		if (!field.relationship || !field.collection)
		{
			writeIndent(writer, 1).append("public void set")
				.append(capName)
				.append("(")
				.append(field.typeName)
				.append(" ")
				.append(field.name)
				.append(") {");
			writer.newLine();
			writeIndent(writer, 2)
				.append("ValueContextForUpdate updateContext = getValueContextForUpdate();");
			writer.newLine();
			writeIndent(writer, 2).append("if (updateContext != null) {");
			writer.newLine();
			writeFieldSetter(writer, field);
			writer.newLine();
			writeIndent(writer, 2).append("}");
			writer.newLine();
			writeIndent(writer, 1).write("}");
			writeBreak(writer);
		}
	}

	private void writeFieldGetter(
		BufferedWriter writer,
		Field field,
		String path,
		boolean useRecord)
		throws IOException
	{
		String varName = useRecord ? REC_VAR_NAME : CONTEXT_VAR_NAME;
		writeIndent(writer, 3).append("return (")
			.append(field.typeName)
			.append(") ")
			.append(varName)
			.append(".get");
		if (!useRecord)
			writer.write("Value");
		else if (field.collection)
			writer.write("List");
		writer.append("(").append(path).append(");");
		writer.newLine();
	}

	private void writeFieldSetter(BufferedWriter writer, Field field) throws IOException
	{
		String path = "Path.parse(\"." + field.node.getPathInAdaptation().format() + "\")";
		if (field.relationship)
		{
			if (field.fk && !field.collection)
			{

				writeIndent(writer, 3).append("PrimaryKey pk = ").append(field.name).append(
					".getPrimaryKey();");
				writer.newLine();
				writeIndent(writer, 3).write("if (pk != null)");
				writer.newLine();
				writeIndent(writer, 4).append("updateContext.setValue(pk.format(),")
					.append(path)
					.append(");");
			}
			else
			// collection???
			{
				// TODO: should we support this or throw unsupported operation exception?
			}
		}
		else
		{
			writeIndent(writer, 3).append("updateContext.setValue(")
				.append(field.name)
				.append(",")
				.append(path)
				.append(");");
		}
	}

	private void writeEnumClass(BufferedWriter writer, Field field) throws IOException
	{
		List<String> enumVals = field.enums;
		String enumClassName = StringUtils.capitalize(field.name) + "Enum";
		writeIndent(writer, 1).append("public static class ").append(enumClassName).append(" {");
		writer.newLine();
		for (String string : enumVals)
		{
			String enumName = NameUtils.makeClassName(string);
			writeIndent(writer, 2).append("public static final String ")
				.append(enumName)
				.append(" = \"")
				.append(string)
				.append("\";");
			writer.newLine();
		}
		writeIndent(writer, 1).append("}");
		writeBreak(writer);
	}

	private void createFields(List<Field> fields, SchemaNode[] children, String prefix)
	{
		for (SchemaNode child : children)
		{
			if (child instanceof TNodeChild
				&& ((TNodeChild) child).getDefaultViewProperties().isHiddenInDataServices())
				continue;
			if (child.isComplex())
			{
				SchemaNode[] subchildren = child.getNodeChildren();
				String p = child.getLabel(locale);
				if (!StringUtils.isEmpty(prefix))
					p = prefix + "_" + p;
				createFields(fields, subchildren, p);
			}
			else if (child.isTerminalValue() || child.isAssociationNode())
			{
				fields.add(new Field(child, locale, prefix));
			}
		}
	}

	private static final Map<String, String> TYPES = new HashMap<>();
	static
	{
		TYPES.put("string", "String");
		TYPES.put("int", "Integer");
		TYPES.put("integer", "Integer");
		TYPES.put("boolean", "Boolean");
		TYPES.put("dateTime", "Date");
		TYPES.put("time", "Date");
		TYPES.put("decimal", "BigDecimal");
	}

	private static class Field
	{
		private final String name;
		private String typeName;
		private String baseName;
		private final SchemaNode node;
		private boolean fk = false;
		private boolean relationship = false;
		private boolean collection = false;
		private List<String> enums;
		public Field(SchemaNode node, Locale locale, String prefix)
		{
			this.node = node;
			String n = node.getLabel(locale);
			this.name = NameUtils.makeMemberName(prefix != null ? prefix + "_" + n : n);
			initType(node, locale);
		}

		@SuppressWarnings("rawtypes")
		private void initType(SchemaNode schemaNode, Locale locale)
		{
			SchemaNode tableNode = AdaptationUtil.getTableNodeForRelated(schemaNode);
			if (tableNode != null)
			{
				baseName = NameUtils.makeClassName(tableNode.getLabel(locale));
				relationship = true;
				if (schemaNode.getFacetOnTableReference() != null)
					fk = true;
			}
			else
			{
				String typename = schemaNode.getXsTypeName().getNameWithoutPrefix();
				String javaname = TYPES.get(typename);
				if (javaname == null)
					javaname = "String";
				baseName = javaname;
				SchemaFacetEnumeration enumeration = schemaNode.getFacetEnumeration();
				if (enumeration != null)
				{
					List values = enumeration.getValues();
					if (values != null) // static enumeration
					{
						enums = new ArrayList<>();
						for (Object object : values)
						{
							enums.add(object.toString());
						}
					}
				}
			}
			if (schemaNode.getMaxOccurs() != 1)
			{
				typeName = "List<" + baseName + ">";
				collection = true;
			}
			else
				typeName = baseName;
		}
	}
}
